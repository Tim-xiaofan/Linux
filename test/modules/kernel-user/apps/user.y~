#include <stdio.h>
#include <stdlib.h>
#include <error.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <stdbool.h>
#include <signal.h>
#include <time.h>
#include <stdint.h>
#include "ku_ioctl.h"

#define BUF_SIZE    128
#define IP          "127.0.0.1"
#define PORT        7788

static char buf[256];
static bool force_quit          = false;
static const char * devfile     = NULL;
static struct ku_configs cfgs;
static int count  = 1;

static int 
init_cfgs(void)
{
    int i;
    char ip[64];
    cfgs.count = count;

    for(i = 0; i < count; ++i)
    {
        cfgs.configs[i].pid = 2010;
        cfgs.configs[i].fd = 4;
        sprintf(ip, "127.0.0.%d", i + 1);
        cfgs.configs[i].ip = inet_addr(ip);
        cfgs.configs[i].port = htons(41927);
    }
    return 0;
}

static void
print_configs(const struct ku_configs * cfgs)
{
    int i;
    printf("count = %d : \n", cfgs->count);
    for(i = 0; i < cfgs->count && i < KU_MAX_CONFIG; ++i)
      printf("pid=%d, fd=%d, ip=%08x, port=%04x\n",
                  cfgs->configs[i].pid, 
                  cfgs->configs[i].fd, 
                  cfgs->configs[i].ip, 
                  cfgs->configs[i].port);
}


static void 
signal_handle(int signum)
{
	if(signum == SIGINT)
	{
		printf("Preparing to quit...\n");
		force_quit = true;
	}
}

/** devfile ip port*/
static int 
mod_config(int ac, char *av[])
{
	int ret, fd;

	if(ac != 5)
	{
		fprintf(stderr, "mod_config : devfile ip port pid fd\n");
		return -1;
	}
	
	fd = open(av[0], O_RDWR);
	if(fd < 0)
	{
		perror("open");
		exit(errno);
	}

    //set on or off
    int on = KU_ON;
    ret = ioctl(fd, IOCSONOFF, on);
    if(ret == -1)
    {
		close(fd);
		perror("ioctl IOCSONOFF");
		return -1;
    }
	printf("set ku : %d\n", on);
    
    /** read */
    ret = ioctl(fd, IOCGONOFF, &on);
    if(ret == -1)
    {
		close(fd);
		perror("ioctl IOCGONOFF");
		return -1;
    }
	printf("get ku : %d\n", on);
    
    ret = ioctl(fd, IOCSCONFIGS, &cfgs);
    if(ret == -1)
    {
		close(fd);
		perror("ioctl IOCSCONFIGS");
		return -1;
    }
    printf("set configs :\n");
    print_configs(&cfgs);
    
    struct ku_configs _cfgs;
    ret = ioctl(fd, IOCGCONFIGS, &_cfgs);
    if(ret == -1)
    {
		close(fd);
		perror("ioctl IOCGCONFIGS");
		return -1;
    }
    printf("get configs :\n");
    print_configs(&_cfgs);
	
    int i; 
    char buf[128];
    for(i = 0; i < 10; ++i)
    {
        sprintf(buf, "filter-%d\n", i);
        ioctl(fd, IOCADDFILTER, buf);
    }

    char *lst[10];
    for(i = 0; i < 10; ++i)
      lst[i] = malloc(128);
      
    ioctl(fd, IOCLSTFILTER, lst);
    i = 0;
    while(lst[i])
    {
        printf("%s\n", lst[i]);
        i++;
    }
    for(i = 0; i < 10; ++i)
      free(lst[i]);
	
    close(fd);
	return 0;
}

int main(int ac, char *av[])
{
	int ret, devfd;
	time_t tm;

	if(ac < 2)
	{
		printf("Usage : ./program devfile\n");
		return -1;
	}

	signal(SIGINT, signal_handle);

	devfile = av[1];
	printf("devfile = %s\n", devfile);
	devfd = open(devfile, O_RDWR);
	if(devfd < 0)
	{
		perror("open");
		exit(errno);
	}

	//config mod
	--ac;
	++av;
    init_cfgs();
	if(mod_config(ac, av) == -1)
	{
		fprintf(stderr, "mod_config failed\n");
		goto done;
	}

	while(!force_quit)
	{
		tm = time(NULL);
		sprintf(buf, "fake time : %s", ctime(&tm));
		ret = write(devfd, buf, strlen(buf) + 1);
		if(ret < 0){
			fprintf(stderr, "ret = %d\n", ret);
			perror("write");
			break;
		}
		//break;
		usleep(1000000);
	}

	ret = read(devfd, buf, BUF_SIZE);
	if(ret < 0){
		perror("read");
	}
	else
	{
		printf("data from kernel : %s\n",buf);
	}


done:
	close(devfd);
	printf("done.\n");
	return 0;
}
